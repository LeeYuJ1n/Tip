#include <iostream>

using namespace std;

int main()
{
    // 포인터 복습

    // 포인터의 기본적인 형태

    int a = 10; // 그냥 자료
    int* a_ptr; // 이게 포인터

    a_ptr = &a; // 포인터에 값 넣기
                // &a : a라는 자료가 있는 메모리의 위치
    
    *a_ptr;     // 포인터 변수가 가지고 있는 값
                // 해당 메모리 위치에 기록된 데이터 = 원래 자료

    cout << a << endl;      // a라는 자료 출력하기
    cout << a_ptr << endl;  // a_ptr이라는 포인터 출력하기
    cout << &a << endl;     // a라는 자료가 있었던 메모리 위치 확인하기 = a_ptr과 일치하는지 확인하기
    cout << *a_ptr << endl; // a_ptr이라는 메모리 위치에 있는 값 확인하기 = a와 일치하는지 확인하기

    cout << endl;
    cout << "-------------------------------------------------" << endl;
    cout << endl;

    // 포인터의 기본적인 응용

    // 1. *와 &가 그래서 실제로 정확히 무슨 의미냐?

    // *
    int b = 200; // * 없는 변수. 뜻은 문자 그대로 'b라는 이름을 가진 자료'
    int* b_ptr;  // * 달린 변수. 뜻은 이 자료의 이름은 b_ptr이며, 
                 //   이 자료의 값은 숫자가 아니라, "따라가면 숫자가 있는위치"

    b_ptr = &b;  // & 달린 호출. 뜻은 조금 아래에

    *b_ptr;      // * 달린 호출. 뜻은 "b_ptr을 따라갔을 때 나오는 실제 값"

    // * 연산자 (포인터 연산자, 참조 연산자)

    // 뜻 : "연산자에 의해, 오른쪽의 변수가, 주어진 자료를 참고했을 때"
    
    // 경우의 수에 따른 더 구체적인 의미
    // -> 자료가 처음 만들어질 때 *가 쓰인다면 : "이 변수는 실체가 아니고, 다른 변수를 참조하기 위한 매개체입니다"란 뜻 = 메모리 주소
    // -> 한 번 만들어진 자료를 다시 호출할 때 *가 쓰인다면 : "이 변수를 참조해서 호출했더니 이런 결과가 나왔습니다" = 실제 값

    // ------------------------------------------------------------------

    // &
    int c = 300;      // 자료
    int* c_ptr = &c;  //  & 달린 호출. 뜻은 "c를 참조하려면 이 메모리 위치로 오시오"

    // int& ccccc; // & 달린 변수. 뜻은 "cccc라는 값을 어딘가에서 참조해서 대변한다"
                   // 다른 말로, "어딘가에 int 자료가 있고, 그 자료를 다시 ccccc라는 이름으로 쓰겠다
                   // 또 다른 말로, "이 변수는 명백한 숫자(이미 있던!)를 다룬다"

    int& c_ref = *c_ptr; // & 달린 변수에 포인터 같이 쓰기
                         // 뜻 : c_ptr라는 위치에 숫자가 있으니, 그 자료를 다시 c_ref라는 이름으로 쓰겠다

    // & 연산자 (주소 연산자, 위치 연산자, 지칭 연산자, 번지 연산자 "address operator)
    // 뜻 : "이 연산자에 의해, 오른쪽 변수를, 정해진 위치에 참조를 시켰을 때"

    // *과 반대이기 때문에, 각 경우의 의미도 반대

    // 자료가 처음 만들어질 떄 &가 쓰인가면 : 이 변수는 단순 참조나 새로운 자료가 아니라, "수행된 참조에 의한 결과"입니다
    //                                     = 메모리 주소에 있던 실제 자료

    // 한 번 만들어진 자료를 호출할 때 &가 쓰인다면 : 이 자료를 참조하려면 메모리 주소 어디어디로 오세요
    //                                             = 자료가 있는 메모리 주소

    // c++의 std::cout, std::cin에 대응하는 c의 함수가 printf와 scanf인데
    // scanf에서 입력을 받아서 저장해야 할 변수에 자꾸 & 등을 붙였던 이유
    // 여기서 & = 해당 위치에 직접 데이터를 넣겠다

    // 한 번 Direct X 대목에서 벡터 계산등을 할 때, 반환형이나 매개변수 등에 &가 쓰인 이유
    // = 반환형도, 매개변수도, 자료형에 &가 붙은 것 = 해당 자료를 직접 실체로서 다루겠다
    // = 벡터 계산을 했는데 새로운 값이 나왔다면 그 새로운 값을 본래의 실체가 있던 곳에 덮어씌우는 것

    // -----------------------------------------------------------

    // 2. 다중 포인터에 대해서

    // -> 이론적으로는 무한한 (정확히는 메모리가 버틸 만큼의) 포인터 중첩 가능
    // -> 하지만 현실에서는 보통 2~3중 포인터 내에서 사용이 끝난다

    // 다중 포인터, **(그리고 &&)의 의미란?
    // -> 자료를 참고한 주소, 다시 그 주소를 기록한 주소

    int x = 0;                // 자료
    int* x_ptr = &x;          // x라는 자료가 있는 곳
    int** x_ptr_ptr = &x_ptr; // x라는 자료가 있는 곳인 x_ptr이 다시 컴퓨터에 기록된 곳

    // -> 이해할 때는 그냥 포인터끼리 꼬리물기를 한다고 생각해도 괜찮다

    // 위에 적었던 *와 &는 반대이므로, 실제 값 사용에는 똑같이 &&를 붙여주면 된다

    int y = x;                         // 자료
    int& ref = *x_ptr;                 // x_ptr에 있는 실제 자료
    // int&& y_ref_ref = *x_ptr_ptr;   // 참조의 실체의 실체라는 개념까지 끄집어내면 자료의 취급이 약간 다르다 (중간 자료가 여전히 포인터)

    // 호출 역시 다중 포인터 숫자만큼 **를 붙여주면 된다

    cout << x << endl;           // 그냥 출력
    cout << *x_ptr << endl;      // x_ptr의 값을 출력(x_ptr을 참조해서 나온 결과)
    cout << **x_ptr_ptr << endl; // x_ptr_ptr의 값의 다시 값을 출력 (참조한 결과를 또 참조해서 나온 결과)

    // ----------------------------------------------------

    // 3. 포인터는 int 외의 자료형에도 쓸 수 있다!

    // 실수, bool, 문자와 문자열, 심지어 클래스까지도
    // -> 너무나 당연하지만, 응용하는 입장을 처음 겪으면 매번 헷갈리는 부분
}