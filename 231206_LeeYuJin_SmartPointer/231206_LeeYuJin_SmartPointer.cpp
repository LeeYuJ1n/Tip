#include <iostream>

using namespace std;

// 스마트 포인터
// -> 포인터가 똑똑하다는 건 무슨 의미인가?

// C++이라는 환결과 포인터의 특성을 알아봐야 한다

// -> C++은 개발자에게 많은 자유를 준다. 그런데 그만큼 방치하기도 한다
//    개발자가 객체를 너무 많이 만들어서 메모리가 꽉 차서 쓸 수 없게 되어도 그냥 그러게 내버려둔다 그러나 뻗는다

// -> 포인터도 개발자에 큰 자유를 준다. 그래서 C++ 개발자들이 포이너를 애용하며
//    현실 개발에서 대부분의 객체는 포인터로 딘 인스턴스로 만들어져 있다
//    그리고 포인터로 인스턴스를 만드는 과정에서, 대부분은 해당 데이터가 힙 영역으로 간다 (수동 할당)

// -> 여기서 알 수 있는 사실 = C++에서 포인터를 쓰면 쓸수록 메모리가 부족해질 위험도 커진다

// 일반적으로, 포인터 인스턴스는 앱이 종료되면 같이 삭제되긴 한다 - 하지만 이 "보험"은 os입장에서 안전하다는 이야기
// 앱 실행 중에 메모리가 안전하다는 이야기는 절대 아니다

// 그래서!

// 이런 포인터의 단점을 극복하기 위한 시도들이 그동안 있었다

// 크게 나누면 : 
// 1. 메모리 주소를 한 군데에 몰아서 목록으로 관리하다가 사용자, 혹은 컴퓨터가 지시하면 지금 참조 안 하는 메모리를 싹 다 골라서 지워버리기
// 2. 그냥 인스턴스가 만들어질 때, 가까운 곳에 미리 삭제를 예약 삭제 조건을 예약시키기
//    그래서 이후 해당 조건이 충족될 때, 인스턴스 역시 삭제가 되도록 만들기
//    = 클래스 내에서 인스턴스를 만들면, 해당 클래스가 소멸자를 부를 때 그 안에 인스턴스도 다 delete하기
//    C++에서는 좀 더 자주 선택되는 기법

// 2번을 우리 식으로 말하면 결자해지 ("만든 자가 지워라") 혹은 그 자리에서 쓰고 바로 폐기하기
// -> 이 기법을 지칭하는 개념이 "스마트 포인터"라는 용어의 출발

// 그리고 이 스마트 포인터 기법을 C++이 이후에 수용해서 현재 이 스마트 포인터 기법을

// * 개발자가 직접 의도하지 않아도 (직접 일일이 delete를 작성을 안 해도) 참조가 끝나는 순간 바로 지워지게 *
// 할 수 있는 기능을, 현재 버전 기준, 기본적으로 지원하고 있다

// 이를 스마트 포인터 클래스라고 한다

// ----------------------------------------------------

// 포인터 사용과 관리를 간단히 나타내기 위한 모형 클래스와 "씬"을 만들어 써보자

// ----------------------------------------------------

// 모형 클래스
// (여기서 간단히 작성하지만, 실제로도 현실 개발에서 같은 원리로 동작하는 클래스)

class TestClass
{
public:
    int* a_ptr = new int(100); // 정수도 new 사용 가능

    TestClass() // 클래스엔 생성자가 있다
    {
        cout << "테스트 클래스를 만들었습니다" << endl;
    }

    ~TestClass() // 소멸자도 있다
    {
        // 원래라면 소멸할 때 여기서 코드 실행
        cout << "이 클래스는 더는 없습니다" << endl;

        delete a_ptr; // 소멸자가 호출되면 포인터 변수도 지워지게 설정하기
    }

    void Use() // 사용하기 위한 함수도 있다
    {
        cout << "시험을 위한 클래스 함수를 사용합니다" << endl;
    }
};

void TestScene() // "테스트 장면"
{
    // 지금은 함수라는 형태로 만들지만, 현실 개발자라면 이것 역시 클래스로 만들 수 있다
    // 클래스로 만든 장면이라면 아마 매니저 등으로 관리할 것
    // 그러나 클래스나, 함수나, 시작이 있고 끝이 있다는 점에서는 똑같다

    // ----------------------------------------------------------------------

    // 그러므로 여기서 뭔가를 만드고 수행하면 지금 여기서 시작
    // = 여기서부터 이 아래까지 중간에 코드를 작성하면 장면 중에 일어나는 모든 일들이 된다

    // ----------------------------------------------------------------------

    // 여기서 위에 만든 테스트 클래스를 만들어서 돌려보자

    // 일반적으로 클래스를 객체로 만들 때는 포인터로 인스턴스를 만드는 경우가 많다
    // TestClass* tc = new TestClass(); // 이름 없이 인스턴스를 만들고, 그 주소를 tc로 지정
                                        // 그렇다면, 이 이름 없는 인스턴스는 지금 어디 있을까요?
                                        // -> 당연히 메모리 어딘가. 정확히는 "힙"이라는 영역
                                        // 힙 : 개발자가 수동으로 데이터를 할당하는 곳
                                        // 힙의 장점 : 자유롭다
                                        // 힙의 단점 : 개발자가 직접 청소 안 하면 어질러진다 (그게 인스턴스가 만들어지면 지워져야 하는 이유)

    // tc->Use();

    // 스마트 포인터 클래스를 장면에서 써 보기

    // unique : "고유 포인터"라는 이름의 스마트 포인터 클래스
    //          고유한 포인터를 갖고 있기 때문에
    //          1. 이 주소의 참조가 끝나면 즉시 스스로를 지운다
    //          2. 한 주소가 한 명칭만을, 한 명칭은 한 주소만을 가진다

    unique_ptr<TestClass> utc(new TestClass()); // 대입 연산자(=) 없이, 생성자에서 곧바로 인스턴스를 제작, 할당

    utc->Use();          // 일반 포인터와 별 다를 바 없이 사용 가능
    cout << utc << endl; // utc의 주소 확인 (utc가 포인터가 맞다는 것을 확인)

    // 고유 포인터에 대한 약간의 추가 활용 방법 : 
    // 1. 명칭 이전 (소유권 이전) : 주소의 이름을 바꾼다 (혹은 변수 입장에서 주소의 소유권을 바꾼다)

    // unique_ptr<TestClass> utc2 = utc; // 이렇게 대입 못 한다
    unique_ptr<TestClass> utc2 = move(utc); 
    // std 네임스페이스 안에 있는 move 함수를 사용하면 utc의 내용을 utc2로 이전을 해준다
    // 다시 말해, utc는 이제 메모리 주소를 가지지 못하고, utc2가 utc의 내용을 가져간다

    cout << utc << endl;   // 원래 스마트 포인터 변수의 주소 확인
    cout << utc2 << endl;  // 이전된 스마트 포인터 변수의 주소 확인

    // 이전된 두 포인터의 호출 확인
    utc ->Use();
    utc2->Use();

    // 위 호출에서 함수 호출이 안 되었어야 할 utc도 의외로 함수 호출이 된다
    // -> 스마트 포인터 클래스가 문자 그대로 클래스라서 = 주소 이외에도 가지고 있는 다른 자료들이 있는데
    //    그 중에는 "내 주소 가져간 새 고유 포인터" 같은 정보도 있다 (반대도 있다)
    
    // 이전된 고유 포인터가 아직 남은 상태에서 최초의 고유 포인터를 호출해도, 본래 소유주(지금 같은 경우 utc2)를 찾아가서 일종의 "차용"을 한다

    // 이런 식으로 고유 포인터를 쓰려고 시도할 수는 있다 (당연히 비추천)
    // -> 고유 포인터의 취지에 안 맞고 + 나중에 같은 방법으로 자기한테 새로운 주소가 이전될 수 있으니까

    // 그냥 고유 포인터는 한 주소에 한 명칭, 한 명칭에 한 주소만 쓰는 것이 가장 좋다

    // 2. reset을 통한 메모리 주소 삭제 (할당 해제)
    utc->Use();   // <- 포인터로 호출해서, 해당 포인터(테스트 클래스)의 기능을 사용하는 것
    utc2.reset(); // <- 포인터로 호출한 것이 아니라, unique_ptr라는 별도의 클랫의 내부 멤버 변수 자격을 호출한 것
                  //    그래서 포인터 위치 데이터 ( = 테스트 클래스)의 기능을 . 연산자로 들어갔을 때는 사용 불가
                  //    대신 unique_ptr 안의 기능을 호출해서 사용 가능 (이것이 C++에서 -> 연산자와 . 연산자가 따로 있는 이유)

    // utc2.release(); // reset의 하위호환 함수. 주소의 참조는 계쏙 한다. 그러나 utc2의 내용에서는 삭제
                       // utc2였던 메모리 주소는 계속 살아 있지만, utc2라는 변수는 해당 주소를 찾지 못한다
                       // -> 고인물 프로그래머가 "100% 수동으로" 여러 개의 고유 포인터의 참조 상관관계를 바꾸고 싶을 때 쓰는 함수
                       // -> 보통은 거의 안 쓴다는 이야기. (참조 상관 관계를 바꾸고 싶으면 위에 move있는데 그거 쓰면 더 좋지 않은가?)

    // 그래서, 지금 사용한 reset()는 무엇인가?
    // reset() : 고유 포인터가 가진 해당 메모리 위치 참조 사실을 리셋(초기화)
    //           -> 고유 포인터는 한 주소가 한 명칭밖에 대응하지 않는데, 그렇게 명명된 변수가 참조를 멈추었다?
    //           -> 해당 주소는 참조하는 변수가 없다
    //           -> 이 시점에서, 고유 포인터의 대상 데이터는 스스로를 메모리에서 삭제했다

    cout << utc2 << endl; // <- utc2라는 명칭의 변수는 있지만, 이 변수는 이제 메모리의 어디도 참조하지 못한다

    // 이렇게 reset을 부름으로써 일반 포인터에 delete를 쓴 것처럼 사용자가 고유 포인터도 어느 정도는 수동으로 관리 가능
    // -> 안 그래도 알뜰한 메모리 사용을 더욱 알뜰하게 쓸 수 있다

    // ----------------------------------------------------------------------

    // 다른 스마트 포인터 클래스도 써보기
    
    // shared_ptr : 공유 포인터, 셰어드 포인터
    //              한 주소에 공유된 참조 목록을 만들어서, 여러 스마트 포인터 클래스가 참조할 수 있도록 배려한 포인터
    //              -> 여러 스마트 포인트 변수가 해당 주소를 나누어서 참조할 수 있다
    //              -> 물론 고유 포인터와 마찬가지로 명칭 이전도 원하면 할 수는 있다
    //              -> 여러 명칭이 참조를 하고 있기 때문에, 한 변수가 참조를 그만둬도(reset) 다른 변수는 계속 참조
    //              -> 그러다가 해당 주소의 참조 변수의 개수가 0으로 떨어지면, 그 때 메모리를 해제(인스턴스를 삭제)

    cout << endl;
    cout << "--------------------------------------------------" << endl;
    cout << endl;

    shared_ptr<TestClass> stc(new TestClass());

    stc->Use();

    shared_ptr<TestClass> stc2(stc); // stc의 참조 사실을 공유해서 새로운 공유 포인터 작성

    stc2->Use(); // stc2도 같은 대상 클래스 기능 사용 가능

    // ----------------------------------------------------------------------

    // 공유 ㅍ인터가 참조를 나누는 형태를 조금 더 확실하게 알아보기

    shared_ptr<TestClass> shtc(new TestClass());

    cout << shtc.use_count() << endl; // 이 공유 포인터의 대상 주소가, 현재 몇 군대에서 참조가 되고 있는지 검사하는 함수

    // + unique() : 해당 포인터를(만) 고유 포인터인 것처럼 사용 가능 : 잘 안 쓴다 (고유 포인터가 정 필요하면 그냥 공유 포인터 쓰면 되는데)

    // 위 use_count() 함수로 참조 횟수 확인 가능

    shared_ptr<TestClass> shtc2(shtc);

    cout << shtc.use_count() << endl;  // 처음 만든 공유 폴더의 참조 횟수 확인
    cout << shtc2.use_count() << endl; // 나중에 만든 공유 포인터의 참조 횟수 확인

    // 참조 횟수가 1 이상인 상황에서, 처음 만든 shtc를 참조 초기화를 해보기
    shtc.reset(); // 처음 만든 공유 포인터 참조 초기화(해제)
    
    cout << shtc << endl;
    cout << shtc2 << endl;

    // shtc->Use(); // <- 해제를 했는데 사용을 왜? (실행이 되든 되지 않든 좋은 코드는 아닙니다)

    shtc2->Use();   // 처음 포인터에서 공유를 받았지만, 아직 자기는 참조 해제를 안 한 상태
                    // -> 해당 데이터를 쓸 수 있을까?

    // 참조 횟수 마지막 확인
    cout << shtc.use_count() << endl;
    cout << shtc2.use_count() << endl;

    // 이렇게 공유 포인터를 사용하면, 전체 데이터가 있고 해당 데이터의 메모리 주소를 여러 곳에서 참조할 때
    // 메모리 낭비를 줄이면서도 (참조가 0이면 메모리가 해제)
    // 한편으로는 여러 포인터 변수가 한 메모리 주소를 똑같이 접근해줄 수 있게 해준다

    // 예 : "캐릭터"라는 데이터에 "플레이어"라는 이름의 변수와 "파티원"이라는 변수가 모두 접근하는 상황
    //      (RPG에서 한 플레이어가 파티에 소속된 경우 파티원 수정 결과를 플레이어가 확인 가능
    //       그러면서도 플레이어가 접속을 종료하면 (플레이어 종료, 파티원 삭제) - 해당 데이터 참조 해제 가능)

    // ----------------------------------------------------------------------

    // shared_ptr는 여러 변수에서 데이터를 참조할 수 이쎅 해준다

    // 약점 : 공유 포인터는 기준 데이터가 있고, 거기에 각각 어디서 참조를 하고 있느냐에 따라서 해당 메모리 주소가 해제될지 아닌지 판단
    //        -> 참조 횟수가 0이 되지 않으면 절대 해제되지 않는다

    // -> A 클래스가 있고, 거기에 다른 A 객체가 멤버 변수로 들어가는데,
    //    해당 객체 A를 향한 공유 포인터가 또 있는 경우
    //    -> 그래서 A 클래스를 통해서 B, C 인스턴스를 만들었는데
    //       C는 B를 참조하고, B는 또 C를 참조하는 상황
    //       -> 더 심한 경우는 1, 2, 3, 4, 5라는 객체가 있는데 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5, 5 -> 1
    // = 순환 참조, 상호 참조를 일으켰을 때, 하나를 지워도 다음 자료가 있기 때문에 계속 메모리가 살아있는 경우 발생
    //   그런 문제가 발생하면 공유 포인터는 스스로를 지우지 않는다 (메모리 해제를 하지 않는다 = 참조가 0으로 떨어지지 않는다)

    // 그래서 위 문제를 해결하기 위한 두 가지 방법
    // 1. 간단하고 확실하게, 본인이 어느 시점에서 공유 포인터 변수 중 하나를 적절하게 reset하기 (사람은 귀찮다)
    // 2. 또 다른 스마트 포인터 클래스를 사용해서, 공유 포인터 클래스의 의존도를 낮추기
    //    = 공유 포인터에 똑같이 접근 가능하지만, 공유 포인터 클래스 관리 상황에는 영양을 주지 않는다
    //    오로지 "보는 것"에만 특화된, 수정불가 간섭불가 수준의 '약한' 스마트 포인터 클래스가 존재

    // ----------------------------------------------------------------------

    // weak_ptr : 공유 포인터와 같이 사용할 수 있는 스마트 포인터 클래스
    //            기능 : 기본적으로 공유 포인터의 대상 위치를 참조
    //                   그런데 weak_ptr로 참조한 변수는 추가 조치 없이는 내용 수정은 못 한다 (호출은 가능)
    //                   그리고 weak_ptr로 참조한 변수는 shared_ptr의 참조 횟수에 반영되지 않는다

    cout << endl;
    cout << "--------------------------------------------------" << endl;
    cout << endl;

    shared_ptr<TestClass> rtc(new TestClass()); // raw 테스트 클래스
    shared_ptr<TestClass> rstc(rtc);            // raw를 공유하는 포인터 변수
    weak_ptr<TestClass>   wtc(rtc);             // raw를 공유하는 "약한" 공유 포인터 변수

    // 만든 세 포인터 변수의 데이터 호출하기
    rtc ->Use();
    rstc->Use();
    // wtc->Use(); // <- 이대로는 사용 불가 (이렇게 접근하면 "데이터 그 자체"에 접근하는 셈이라서 : weak_ptr은 수정불가 간섭 불가)
    wtc.lock()->Use(); // weak_ptr 멤버로 들어가서(. 사용) lock 함수를 호출하면 데이터 읽기 전용 사용 가능

    // 각 포인터 변수의 참조 횟수 확인하기
    cout << rtc.use_count() << endl;  // 공유 포인터 참조 횟수 확인
    cout << rstc.use_count() << endl; // 공유 포인터 참조 횟수 확인
    cout << wtc.use_count() << endl;  // 공유 포인터 참조 횟수 확인

    // 위 코드에 따르면 메모리 주소를 참조하는 포인터 변수는 3개지만,
    // 공유 포인터 클래스에서 집계한 메모리 주소 참조 횟수는 2로 표시
    // weak_ptr 참조 횟수는 반영이 되지 않았다

    // 그렇다면 이 포인터 변수들을 reset한다면?
    rtc.reset();   // 처음 만든 공유 포인터 리셋
    rstc.reset();  // 나중에 만든 공유 포인터 리셋
    // wtc는 리셋하지 않는다

    cout << wtc.lock() << endl; // 약한 포인터 변수 확인해보기
    cout << wtc.use_count() << endl;

    // 위 코드 결과 : wtc를 리셋하지 않았지만, 공유 포인터가 모두 리셋된 시점에서 포인터 대상 주소는 스스로를 삭제
    // 대상이 삭제되어서 wtc도 (아직 살아있는데!) 더 이상 대상 데이터를 참조하지 못 한다
    
    // 이렇게 참조만 하고 데이터를 수정할 필요가 없을 때, weak_ptr로 해당 주소를 같이 공유하면
    // 데이터 열람도 하면서 공유 포인터 리셋에 따라 메모리 해제도 편하게 자유롭게할 수 있다 (순환참조 깨기)

    // 스마트 포인터 클래스를 사용하면 별도의 삭제 구문을 입력하지 않아도
    // 참조가 끝나는 시점에서 스스로를 지우므로 메모리 관리에 큰 편리함을 얻는다

    // ----------------------------------------------------------------------

    // 아래 줄까지 가면 이 함수가 끝난다. 클래스 역시 소멸자가 호출되면서 끝날 것!
    
    // 일반적으로 인스턴스를 만들었을 때 지워야 하는 시점
    // delete tc; // 장면 끝에서 (클래스라면 장면 클래스의 소멸자가 
}

int main()
{
    // 장면 실행
    TestScene();

    cout << "아무거나" << endl;
}

// 스마트 포인터에 대해서 추가 설명 조금만 더...
// 1. 스마트 포인터의 실용성 : 실제로 얼마나 쓰느냐?
// -> 결론부터 이야기하자면 C++에서는 사실 필수나 다름없다. 그런데
//    질문의 구체적인 조건에 따라 진짜 대답은 다시 나뉜다

// 1-1. 스마트 포인터"라는 개념"을 얼마나 쓰느냐?
//      -> "포인터 변수를 만들었으면 그 자리에서 다 쓰고 지울 코드도 같이 설계하라"는 원칙을 얼마나 쓰느냐?
//          라는 질문으로 바뀐다면? -> 답은 "늘 쓴다"
//          그래야 C++이라는 언어의 환경에서는 메모리를 조금이라도 알뜰하게 쓸 수 있기 때문에

// 1-2. 마이크로소프트 배포판 C++언어에서 지원하는 스마트 포인터 클래스 3종(고유 포인터, 공유 포인터 약한 공유 포인터)
//      이들을 얼마나 실제로 쓰느냐? -> 라고 질문을 바꾸면 -> 답은 "그때그때 다르다"
//      모든 사람들이 늘 스마트 포인터 클래스를 쓰는 것은 아니다 왜? 

//      이유 1. 단순히 외우기 번거로워서 (사람이 게을러서) <- 결국 개발하는 이유는 사람이 작업 편하게 하려고
//      이유 2. (사람의 문제만이 아니라) 스마트 포인터 클래스 자체의 약점들 때문
//              A. 참조 횟수만을 기준으로 자가 삭제 여부를 판단한다
//                 -> 싱글턴, 전역 변수처럼 참조 종료의 시점이 까마득하게 먼 경우 죽어도 자가 삭제를 안 한다
//                 -> 참조 횟수가 순간적으로라도 0이 되는 순간 칼같이 스스로 자폭을 해버린다
//              B. 한 변수가 클래스 (스마트 포인터라는 클래스)의 내부 변수라는 정체성과 데이터의 메모리 주소( = 포인터)의 정체성을 다 갖고 있다
//                 (->연산자와. 연산자를 구분해서 사용 가능) -> 기능이 많아서 좋다는 뜻도 되고, 문제가 생겼을 때 디버깅하기 어렵다는 뜻도 된다
//                 -> 버그가 났을 때 버그 잡기가 힘들다

//     이유 2를 요악하면 : 스마트 포인터 클래스도 완전 만능은 아닌데, 워낙 기능이 좋다 보니
//                        사람이 기느엥 의존하다가 문제를 일으킬 수 있다
//                        그래서 기능을 통제하기 위해서 좋은 기능도 쓰지 않거나, 반대로 단점을 보완하기 위한 보험 코드를 막 추가
//                        -> 그럴 때 코드 단순하게 쓰기 파가 물어본다 "그럴 거면 이거 왜 쓰냐? (그냥 포이너 쓰지)" <- 딱히 틀린 말도 아니어서 더 문제

// 이 이야기의 결론 : 스마트 포인터 클래스를 쓰자, 혹은 쓰지 말자가 아니다
// 1. 스마트 포인터 클래스가 아니어도, "포인터 변수는 만들었으면 자기가 책임지고 지워야 한다"
//    이 개념만은 C++에서 필수
//    ( = 클래스는 가능하면 소멸자부터, 깜빡 잊고 생성자부터 만들었어도 그 다음에는 소멸자로)
// 2. 만야겡 쓴다면, 무엇이든 해당 코드의 장점과, 쓰는 이유와, 쓰는 방법과, 한계를 알아보고 쓰자
// 3. 적절하게 쓸 수만 있다면 나쁜 코드는 없다 (복잡하든, 단순하든, 쉽든, 어렵든)
