#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

int main()
{
    // 맵의 좀 더 쉬운 사용 방법 이해를 위한 복습

    // 맵의 기본적인 사용

    // 맵의 구성요소는 페어 (두 자료형의 쌍)
    map<int, string> dictionary; // dictionary : 사전. 언어에 따라 맵이라는 자료형을 이렇게 지칭하기도 한다

    // 페어 만들기
    pair<int, string> samplePair1;
    samplePair1.first = 0;
    samplePair1.second = "도화가";

    pair<int, string> samplePair2(1, "도화가 클론");

    // 맵에 자료 추가
    dictionary.insert(samplePair1);
    dictionary.insert(samplePair2);
    dictionary.insert(pair<int, string>(2, "도아가"));

    // 추가한 맵의 자료를 출력
    // for (int i = 0; i < dictionary.size(); ++i) // 벡터처럼 순번으로 출력해보기
    // {
    //     cout << dictionary[i] << endl;
    // }
    // 그러나 이 방법은 엄밀히 말하면 틀린 방법 : 맵의 []연산자는 일반적인 배열과는 작도잉 약간 다르다

    // 확인 : 맵에 불규칙한 int가진 페어를 더 만들어 넣어보고 다시 출력
    dictionary.insert(pair<int, string>(112, "도아가"));
    dictionary.insert(pair<int, string>(111, "스페셜리스트"));
    dictionary.insert(pair<int, string>(90, "기상술사"));

    /*
    for (int i = 0; i < dictionary.size(); ++i) // 벡터처럼 순번으로 출력해보기
    {
        cout << dictionary[i] << endl;

        // 이 반복문 출력 결과 : 이상한 공백의 연속 후에 "도아가"로 출력 종료

        // 이 반복문이 돌아간 사연
        // i가 0에서 시작 -> 처음 세 페어 출력
        // i가 3에 도달하면 -> 딕셔너리에 자료가 없어서 패스 (i는 여기서 1증가)
        // i가 3에 도달하면 -> 원래는 맵 크기를 넘어갔기 때문에 반복문이 중단이 되어야 하는데, map에서는 이 조건이 안 먹히기도 한다
        // (그리고 맵에서 크기와 순번을 비교했을 때 동작하려면, 순번이 맵의 실제 크기많이 아니라 기록된 "마지막 자료의 크기"까지도 넘어가야 할 수도 있다)
        // 우연히 크기에 따른 순번 조건문이 동작하지 않았을 때 -> 딕셔너리[i]를 출려고 했는데...
        // 딕셔너리에는 지금 [3]이 없다 -> 또 반복
        // 또 순번 조건문이 크기에 따라 멈추지 못하고 -> 매번 반복할 때마다 i가 1씩 늘어난다
        // 그래서 i가 112, 111, 90이 되었을 때 한 번씩 i로 입력된 페어의 값이 나온다
        // 마지막 112이 출력된 다음, (맵의 모든 출력이 끝난 뒤) 그 다음에 1 올라간 113에서 비로소 반복문이 끝난다
    }
    */

    for (map<int, string>::iterator it = dictionary.begin(); // 반복자와 시작지점 지정
        it != dictionary.end(); // 반복자가 맵의 끝에 갈 때까지 반복
        ++it)
    {
        cout << it->first << ", " << it->second << endl; // 반복자로 찾아간 메모리 주소의 두 페어 자료 (first, second) 출력
    }

    // 지울 때는?
    dictionary.erase(1); // "1"로 대변되는 뭔가를 지우기 -> 1로 페어의 첫 번째를 작성한 데이터 지우기
    // map에서 뭔가를 지울 때는 메모리 주소나, 통 데이터를 지우는 것이 아니라
    // 첫 번째 데이터로 지정된 "페어"를 지우는 것. 그래서 지우는 대상의 호출도 페어의 첫 데이터 ( = Key)

    cout << endl;
    cout << "--------------------------------------------------------" << endl;
    cout << endl;

    for (map<int, string>::iterator it = dictionary.begin(); // 반복자와 시작지점 지정
        it != dictionary.end(); // 반복자가 맵의 끝에 갈 때까지 반복
        ++it)
    {
        cout << it->first << ", " << it->second << endl; // 반복자로 찾아간 메모리 주소의 두 페어 자료 (first, second) 출력
    }

    // 맵에서 자료를 찾을 때는?
    // cout << dictionary.find(2) << endl; // <- 이대로 쓰면 에러

    // find() : 실행하면 () 안에 매개변수로 넣은 key에 맞는 맵의 데이터...의 메모리 주소(반복자)
    // 따라서 함수를 실행한 결과는 일종의 포인터, 여기서 -> 로 접근한 다음 실제 데이터를 사용
    cout << dictionary.find(2)->first << endl; // 아까 지운 1을 찾으려고 하면?
    cout << dictionary.find(2)->second<< endl;

    cout << endl;
    cout << "--------------------------------------------------------" << endl;
    cout << endl;
    // ----------------------------------------------------------------

    // 위 과정에서 맵에 (잘못됐더라도) []가 사용 가능하다는 점은 확인했다
    // cout << dictionary[90] << endl; // 숫자 하나를 콕 집어서 출력하면, 해당 key에 대한 값(value)이 나온다

    // 그러면, 맵에서 []가 정확히 할 수 있는 일은 무엇일까?

    // 새로운 맵 작성
    map<string, string> newDic; // 숫자가 없는 맵 생성 ([] 안에 숫자를 넣어서는 사용 불가)

    newDic["도화가"] = " 스페셜리스트";
    newDic["도아가"] = "는 아가야!";

    newDic["도아가"] = "는 귀여워!"; // 같은 key, 다른 value

    // []를 맵에 사용하면, 이 안에 key를 넣어서 맵에 새로운 자료를 등록할 수 있다
    // 이 때 [] 안에 들어간 값이 key(혹은 first), = 오른쪽에 들어간 값이 value(혹은 second)

    // []를 맵에 사용했을 때, 단순 추가가 아니라, "등록"이라는 표현을 썼다
    // 그래서 같은 key에 다른 value를 넣으면 -> 새로운 페어가 추가되는 것이 아니라, 있던 keydp 다른 value에 덮어씌워진다

    // 위에서 작성한 []안에 문자열로 맵 찾기와 출력
    cout << newDic.find("도화가")->first << newDic.find("도화가")->second << endl;
    cout << newDic.find("도아가")->first << newDic.find("도아가")->second << endl;

    cout << endl;
    cout << "--------------------------------------------------------" << endl;
    cout << endl;

    // 맵에 []와 키를 써서 호출하면, key는 빠지고, value만 호출하게 된다
    // newDic["도화가"] = newDic.find("도화가")->second

    cout << newDic["도화가"] << endl;
    cout << newDic["도아가"] << endl;

    // ----------------------------------------------------------------

    cout << endl;
    cout << "--------------------------------------------------------" << endl;
    cout << endl;

    // map에서 []를 잘 쓰면, key만을 이용해서 등록된 페어를 손쉽게 추가 / 덮어씌우기 / 호출 세가지를 할 수 있다

    // -> 전화번호부, 인명사전, 인명색인 (번호로 이름 찾기) 등을 만들 떄 유용하다
    //    혹은, 게임 등에서 스테이지 불러오기, 텍스처 바꾸기, 음악 재생하기 등에도 유용하다
    //    (key를 스테이지 이름, 텍스처 테마, 음악 제목 등으로, value는 실제 class, 혹은 파일)

    // ----------------------------------------------------------------

    // ID로 캐릭터 찾기 (의 간단한 모형)

    map<int, string> chaList; // 캐릭터 리스트
    
    // []를 써서 캐릭터 등록
    chaList[0] = "도화가";
    chaList[1] = "도아가";
    chaList[2] = "꼬맹이";
    chaList[3] = "기상술사";

    int input;

    cout << "찾으려는 캐릭터의 ID를 입력하시오 : ";
    cin >> input;

    // 캐릭터를 찾아서 출력
    cout << "찾은 캐릭터 : " << chaList[input] << endl; // chaList.find(input)->second하고 같다, 추천방법

    // 캐릭터를 찾아서 출력
    // cout << "찾은 캐릭터 : " << chaList.find(input)->second << endl;

    // 좀 더 원시적인 방법 : 벡터처럼 대조해서 찾아도 관계는 없다 (코드는 귀찮아지지만)
    // -> find나 아래 ㅂ아법이나 큰 성능은 지금 없어서 추천하지 않지만
    // 그럼에도 불구하고 급하게 탐색을 해야 한다면 "반복자로 일반적인 C++자료구조처럼 탐색을 할 수 있다"

    // for (map<int, string>::iterator it = chaList.begin();
    //     it != chaList.end();
    //     ++it)
    // {
    //     if (it->first == input)
    //     {
    //         cout << "찾은 캐릭터 : " << it->second << endl;
    //     }
    // }

    // 맵 이해에 대한 추가 Q&A

    // 1. 맵에서 자료가 왜 페어인가? 왜 한 자료가 두 데이터 이상을 가지지 못 하는가?
    // -> 첫 번째 대답 : 벡터에서 데이터 검색 안 만드는 이유와 같다 = 힘들고 귀찮아서
    
    // -> 두 번째 대답 : "하나의 key"가 이미 고유성을 짙다.
    //                  그런데 거기에 복수의 데이터가 붙으면, 설명하기 힘드니까
    //                  (정확히는 마음먹으면 할 수 있지만, "모든 게이터를 고유하게" 만들려면 귀찮다)
    //                  따라서 고유성을 사용하는 맵이라는 자료구조의 특성상 데이터 설계의 자유를 위해서는 
    //                  데이터 쌍의 구성이 간단할수록 편하다 (하나의 key, 하나의 value)

    // -> 세 번째 대답 : 벡터에서 데이터 검색 안 만드는 이유와 같다 = 쓰는 입장에서는 알아서 만들면 그만이니까

    // 예시
    map<int, vector<string>> pacipicant; // "참여자들" = 몇 번 참여자 팀
                                         // 여기에 int로 key 받고, 해당 팀 안에 복수의 인명을 할당하면 된다

    // 위 예시처럼 value에 벡터 등 자료구조, 혹은 배열, 혹은 클래스, 혹은 심지어 이부 데이터(SQL)를 배졍하면
    // -> 이름은, 지칭은, 다시 말해 데이터 할당은 하나지만, 그 안에는 독립된 하위 데이터들이 얼마든지 있다
    // -> 이 방법으로 3중, 4중, 그 이상의 다중 데이터 구조를 map으로 활용할 수도 있다

    // 요약 : 맵에 세 데이터 이상은 만들기도 힘들고, 만들 필요도 없다 (기타 자료구조와 같이 응용하면 얼마든지 확장 가능)

    // 2. 다 같은 자료구조 같은데, 왜 벡터가 있고 리스트가 또 있고 맵이 또 있고
    // -> 데이터를 그룹화하는 근본 목적은 모두 똑같지만, 세부 사용 내용 방법 등이 달라서 그렇다
    // -> 상황별로 최적화가 다르다 -> 특화되는 경우가 다르다

    // 벡터 : 설계상, 그리고 현재는 실제 사용에서도, *순번에 공백이 없다*
    //        모든 벡터는 0에서 순번이 출발해서, 1씩 올라가며, n(벡터 크기 -1, 마지막 순번)에서 끝난다
    //        []를 이용해서 *포인터로 접근했을 때*, 관리가 가장 수월하다 (다른 자료구조는 이렇게까지 쉽게 못 쓴다)
    //        -> 그냥 배열 같은 배열을 쓰려는데 그 배열의 크기가 마음대로 늘었다 줄었다 했으면 좋겠다, 그럴 때 가장 좋은 자료구조

    // 리스트 : 두 자료가 서로 연결이 긴밀하게 되어 있을 때, 그런데 정작 그 자료안에 순서상의 명백한 상관관계를 모를 때 좋다
    //         A 다음에는 B가 와야 하는 건 맞는데, B가 실제로 컴퓨터 메모리든, 개념상이든, 게임의 스테이지 내에서든, 아무튼 "어디 있는지는 모를 때"
    //         -> 이런 경우는 순번에 명백한 공백이 생긴다. 그럴 때 리스트를 써서 "어쩄든 A다음은 B다!"라고 명확히 짚고 넘어가야 할 때, 리스트가 좋다

    // 맵 : key를 통해서 데이터를 대변할 수 있다. 순번도, 서로 간의 연결 고리도 애매하지만, 데이터를 찾고 싶을 때
    //      그 데이터를 찾고 싶을 떄, 그 데이터의 명명된 지칭만 무엇인가만 알면 곧바로 해당 데이터를 가져올 수 있다
    //      -> 데이터 1,000,000개가 있어도 key 하나만 알면 반복문 작성이나 자료간의 대조 필요업이 오직 key만 가지고 불러올 수 있다
    //      반면 배열이나 리스트 같은 순번, 상호연결 같은 일괄처리에는 약하다
    //      -> 같은 종류의 데이터가 많이 있을 때, 전체 작업은 적게 하고, 하나하나 데이터를 호출하는 경우가 많다면 맵이 최적

    //      ->  괜히 다른 언어에서 맵이라는 자료구조를 "사전"이라고 부르는 것이 아니다
    //      -> 이름으로 검색해서 오직 그 데이터 하나만을 빠르게 찾는 과정이 사전 검색과 판박이니까

    // 요약 : 다 같은 자료 집합이지만, 자기가 제일 잘 하는 건 각각 다르기 때문에 더 많은 자료구조들이 필요하다

    // -> 자료를 만들었는데 일괄처리 (전체 렌더라든가) 등을 자주 한다면 벡터가 좋다
    // -> 자료 간에 순서가 뒤죽박죽 되기 쉽다면 (A 다음이 B였다가 C였다가 E였다가) 
    //    해당 순서의 관계를 정확히 나타낼 수 있는 리스트가 좋다
    // -> 전체 처리를 하지 않고, 한 번에 하나의 데이터만 콕 집어서 사용할 거라면 맵이 좋다
    //    (캐릭터 액션 처리, 배경 출력, 배경음악 재생 둥)

    // 내가 사용할 데이터가 어떻게 사용되는가를 파악하면 어떤 자료구조가 좋은지 (혹은 적당한지)도 판단 가능
}