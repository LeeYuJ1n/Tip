#include <iostream>
#include <vector> // 벡터 로드
#include <map>    // 맵 로드

// std 생략
using namespace std;

// 자료구조 복습 : 가장 많이 쓰고, 가장 만만한 두 가지, 벡터와 맵

// 변수는 여기서 만들어도 되고, main 안에서 만들어도 OK
// 헤더를 만들어도 OK

int main()
{
    // 벡터의 핵심적인 사항 돌아보기

    vector<int> vecInt; // <>를 사용해서 무엇의 벡터인지를 매번 지정 ( : 템플릿)

    // 벡터의 끝에 구성요소 넣고 빼기
    vecInt.push_back(0); // 벡터에 0 넣기
    // vecInt.pop_back();   // 벡터의 마지막 요소 없애기

    cout << vecInt[0] << endl; // 벡터가 하나짜리니까 0번째가 마지막

    // 코드의 결과를 알고 싶을 땐 언제든지, 해당 코드 직후에 출력을 하도록 합시다
    // (C++에서도, DX에서도, 엔진에서도 모두 통하는 이야기) : 엔진에서도 가장 많이 써야 되는 코드는 Log이다

    vecInt.pop_back();   // 벡터의 마지막 요소 없애기

    // cout << vecInt[0] << endl; // 벡터가 하나짜리니까 0번째가 마지막 <- 좋지 않은 결과 예상

    // 벡터의 크기를 사전에 지정하고 직접 구성요소 넣기
    vecInt.resize(10); // 벡터를 10개짜리로 만들고, 해당 자리를 빈 자리로 만들기

    // 빈 자리 채우기는 for문 일괄처리로

    for (int i = 0; i < vecInt.size(); ++i) // vecInt.size() : 벡터의 크기
    {
        vecInt[i] = i + 1;
    
        cout << vecInt[i] << endl;
    }

    // 아래 for each문도 사용 가능하지만, 프레임워크 등의 사용 인터페이스가 따로 있지 않다면
    // 수동으로 작성하는 코드는 언제나 기본에서부터 출발합시다 - 팁.
    
    // 언제나 기본적인 문법에서 정확하게 돌아가는 것을 확인하고, 그 다음에 이 코드를 줄이는 방법 등을 고려합시다
    // 게임의 미덕은 최적화가 아닙니다. 일단 실행되는 겁니다.

    // DX 중에 배운 for 일괄처리문 (혹은 for each문) 활용

    // int count = 0; // 기준이 될 데이터를 바깥에 작성
    // 
    // for (int i : vecInt) // 벡터 안에 있는 각 구성요소를 i라고 지칭
    // {
    //     // 벡터 속 정수 i를 0번째부터 마지막까지 자동으로 돌리기
    // 
    //     i = count + 1;     // i는 기준 데이터 +1이 값으로 할당
    //     count++;           // 매 실행 시마다 기준 데이터 자체도 +1
    // 
    //     cout << i << endl; // 출력
    // }

    // [] : 순번연산자(인덱스 연산자), 여러 자료가 있을 때, 해당 이름으로 된 데이터의 기준 위치 혹은 
    //      [] 속 숫자의 순번만큼 위치가 조정된 메모리 위치를 가리키는 "포인터"

    // -> [] 연산자가 쓰였다는 사실에서, 벡터 = 배열의 연장 = 포인터의 연장

    // 벡터 안에서 구성요소를 중간에 추가하고, 중간에 빼기
    // insert와 erase만 사용해보기

    cout << "----------------------------------------" << endl;

    vecInt.insert(vecInt.begin() + 4, 999);
    // insert : 벡터의 숫자 넣기 (중간 아무데나)
    // vecInt.begin : 벡터의 기준위치 (매번 이 기준위치를 잡아줘야 한다)
    // + 4 : 이번에 추가할 위치(새 요소가 끼어들어갈 순번), 이거 말고 위의 두 줄은 사실상 공식
    // 999 : 추가하려는 값

    for (int i = 0; i < vecInt.size(); ++i)
    {
        cout << vecInt[i] << endl;
    }

    cout << "----------------------------------------" << endl;

    vecInt.erase(vecInt.begin() + 4);
    // insert와 거의 같다 : 지우려는 값은 입력할 필요 없는 것이 차이

    for (int i = 0; i < vecInt.size(); ++i)
    {
        cout << vecInt[i] << endl;
    }

    cout << "----------------------------------------" << endl;

    // 이 밖에 기억하면 좋은 함수
    
    // vecInt.clear(); // 다 지우기
    
    // cout << vecInt[0] << endl; // 억지로 출력하려고 하면 아마 오류가 날 것

    cout << "----------------------------------------" << endl;

    // 그러면 벡터에 다른 기능은 없나? 필요없나?

    // 더 많은 기능이 있고 그 중에는 앞으로 써야 할 것들도 있다

    // 대표 사례 : vecInt.swap(). // 벡터 내의 두 구성요소를 위치를 바꾸기 (swap 식으로)
    
    // 이렇게 많은 벡터의 기능을 어떻게 매번 정확하게 쓸 수 있는가?
    // -> 많이 쓰고 많이 위우면 된다 : 시행착오를 오랜 경험을 요구. 초심자에겐 비현실적인 이야기

    // -> 그렇기 때문에, 개발을 처음 진행할 때는 *클래스에 대한 기술 문서*를
    //     궁금한 것이 생길 때마다, 필요한 것이 생길 때마다, 찾읍시다. - 팁

    // 특히 C++의 가장 많은 사용 버전이 MS 배포버전이고,
    // 따라서 마이크로소프트에서 만든 기술 문서는 곧 C++의 사용 설명서
    // -> 어떤 복잡한 교재도, 명확한 설명도, 실제로 그거 만든 사람이 남겨준 사용설명서보다 

    // -> 이것이 벡터를 풍부하게 사용할 수 있는 첫 번째 방법

    // -------------------------------------------------

    // 벡터가 가변 자료구조의 모든 것을 지원하는가 하면 그것도 아니다
    // 벡터에는 값 검색과, 표적이 되는 데이터에 대한 삭제 기능이 지원되지 않는다

    // 왜? 이유는 두 가지. 첫 번째 : 이걸 기본 기능으로 만들려고 하면
    // 벡터를 만드는 입장에서는 힘들고 귀찮은 작업이 되기 때문

    // -> 벡터는 기본적으로 그냥 메모리 위치를 관리해주고, 복수의 데이터를 한 집합으로 묶어주는 역할
    //    그 안에서 데이터까지 책입지고 관리하려고 만든 건 아니었기 때문 (벡터 ≠ 포인터)

    // 두 번째 : 반대로 벡터를 쓰는 입장에서 생각해보면?
    // 벡터는 배열이고, 따라서 []로 쉽게 접근할 수 있다. 벡터에는 값이 있다
    // for문을 돌리면 그 값을 쉽게 볼 수 있다. 배열이라서 위치 바꾸기도 쉽다 (swap까지도 필요없이)
    // 벡터에는 구성요소 더하기 빼기 함수도 있다. for문을 돌리면 값의 2차 정보도 기록이 얼마든지 가능하다 (코드는 우리가 만드니까)

    // ... 쓰는 입장에서 값을 검색하고, 데이터를 삭제하는 건 약간의 기본을 응용하는 걸로 충분히 가능

    // -> 한 클래스에서 기능이 없다고 해서, 그 기능을 쓸 수 없다는 뜻이 아니다!

    // 오히려 기본적인 코드만 가지고도 "스는 입장"에서 얼마든지 응용이 가능한, 쉬운 기능이기 때문에

    // 굳이 안 만들었을 가능성도 있는 것.

    // -> 따라서 클래스에 원하는 기능이 없었다면, 해당 기능을 우리가 만들 수 있는 가능성에 대해서도 

    // 항상 생각을 해 보도록 합시다. -> 중요한 건 기본을 항상 잊지 않는 것, 그리고 시행착오와 도전

    // --------------------------------------------------------------------

    cout << "----------------------------------------" << endl;

    // 벡터에서 데이터를 찾아내기

    // 요점 : 무식하게 for문을 돌려서, 찾으려는 데이터와 일치하면 해당 값을 받으면 그만이다

    vector<int> vec;

    for (int i = 0; i < 20; ++i) // 20번 반복문
    {
        vec.push_back((i + 1) % 10); // (i + 1)을 10으로 나눈 나머지를 벡터에 추가 (=1부터 0까지 반복해서 넣기)
        cout << vec[i] << endl;
    }

    // 이 시점에서 1부터 0까지의 숫자가 두 번 반복해서 들어간 20개짜리 벡터 완성

    // 여기서 "처음부터 돌려서 5찾기"를 만들기

    int result; // 결과값을 받기 위한 정수변수

    result = -1; // 기본 결과 (-1 : 없음 혹은 오류라는 뜻)

    for (int i = 0; i < vec.size(); ++i) // 0부터, 벡터 끝까지 가는 반복문
    {
        // 매 반복문마다 해당 순번의 값이 찾으려는 5가 맞는 지 알아보기

        if (vec[i] == 5)
        {
            // 맞으면 결과 반영하고 검색 종료
            result = i;
            break; // 반복문 종료
        }
    }

    // 결과 출력
    cout << "찾으려는 값의 순번 : " << result << endl;

    // 이렇게 검색하는 과정을 만드는 건 그냥 벡터 학습으로 끝나는 것이 아니다
    // -> 실제 개발에서도 응용해야 될 부분에 들어가니까 외우기보다 이해

    // 이어서, 벡터에 데이터가 몇 개 있는가 찾기

    result = 0; // 결과값 리셋 (0개)
    
    // 시험용. 벡터에 찾으려는 값을 수동을 더 넣어보기
    // vec.push_back(5);
    // vec.push_back(5);
    // vec.push_back(5);
    // vec.push_back(5);
    // vec.push_back(5);

    for (int i = 0; i < vec.size(); ++i)
    {
        // 마찬가지로 찾으려는 값이 현재 순번의 값과 일치하는가
        
        if (vec[i] == 5)
        {
            result++; // 결과 수정
        }

        // 이 과정을 반복문 끝까지 수행하면 된다
    }

    // 데이터 찾기도 그렇고, 빈도도 그렇고... 너무 무식한 거 아니냐 하실 수도 있겠지만
    // 검색의 기본은 원래 대조입니다. 이게 원칙이에요.

    // 나온 데이터 개수를 출력
    cout << "찾으려는 숫자의 총 개수 : " << result << endl;

    // 이렇게 반복문과 조건문만 잘 써도 벡터에서 데이터 검색하는 것 정도는
    // 벡터를 쓰는 입장에서 쉽게 만들 수 있다!

    cout << "----------------------------------------" << endl;

    // 벡터에서 특정 데이터를 지우기 (특정 순번이 아니라)

    // -> 이번에도 5라는 데이터를 한 번 지워보겠습니다

    // 먼저 5가 어디 있는지 알기

    // result = -1;
    // 
    // for (int i = 0; i < vec.size(); ++i)
    // {
    //     if (vec[i] == 5) // 데이터가 검색되면
    //     {
    //         result = i; // 결과 반영
    //         vec.erase(vec.begin() + result); // 바로 i를 써도 사실 가능
    //         break;
    //     }
    // }

    // 위 방법을 쓰면 벡터에서 가장 처음 나오는 5하나를 지울 수 있다
    // 벡터에서 제일 처음 나오는 단일한 데이터를 지울 때는 위처럼 사용 가능

    // 그리고 코드를 번거롭게 사용하지만 대신 더 안정적으로 지울 수 있는 방법

    // for (int i = 0; i < vec.size(); ++i)
    // {
    //     cout << vec[i] << endl;
    // }

    // -------------------------------------------------------------------------

    // for (int i = 0; i < vec.size(); ++i)
    // {
    //     if (vec[i] == 5)
    //     {
    //         int tmp = vec[vec.size() - 1]; // 벡터 크기 -1은 = 벡터의 끝 순번. 따라서 tmp값은 벡터의 마지막 값
    //         vec[vec.size() - 1] = vec[i];  // 마지막 값 위치에 vec[i] 넣기
    //         vec[i] = tmp;                  // i 번째에 tmp 넣기
    // 
    //         // 위 처럼 위치를 바꾸면 지우려는 값이 벡터의 끝으로 간다
    //         // 그러면 위치 굳이 알 필요 없이 pop_back 쓰면 끝
    // 
    //         vec.pop_back();
    //         break;
    //     }
    // }

    // 이렇게 하면 코드가 번거롭지만 pop_back을 써서 벡터를 안정적으로 쓸 수 있다
    // 대신 다른 문제가 한 가지 예상...-> 데이터의 순서가 꼬일 수 있다

    // ---------------------------------------------------

    // 데이터를 여러 개 찾는 게 가능했으니까, 이번엔 여러 개 지우는 것도 가능하지 않을까?

    int count = 0; // 찾은 데이터의 개수

    // 먼저 데이터 개수부터 찾기 (위에서 적은 복수 데이터 검색과 동일)

    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i] == 5)
        {
            count++;
        }
    }

    // 여기까지 오면 count가 결정 (찾으려는 데이터 총 개수)

    // 데이터 지우기를 반복문으로 수행 (하나한 찾아서, 보이는 족족 다 지울 테니까)

    vec.push_back(3);
    vec.push_back(3);
    vec.push_back(3);
    vec.push_back(3);

    for (int i = 0; i < vec.size(); /*++i*/)
        // 반복문 수행시 변화 조건을 삭제 : 반복시 변화가 없다는 뜻이 아니고
        // 변화하긴 하는데, 해당 조건과 상황이 정해져 있다는 뜻입니다.
        // (어떤 조건에서는 반복 시에 i가 바뀌지 않을 수 있다는 뜻입니다)
    {
        if (vec[i] == 3) // 3을 다 지워봅시다
        {
            vec.erase(vec.begin() + i); // 3이 있었던, i 순번을 지우기
            // 지우긴 했는데, 이러면 뒤에 있는 데이터가 앞으로 당겨집니다.
            // 지우기 전에 i + 1번째였던 데이터가 지워진 시점에서 새로운 i번쨰가 돼요
            // 그런데 i를 하나 뒤로 남기면, 지워진 데이터 바로 직후의 데이터는
            // 검색 대상에서 제외됩니다. 따라서, 지우기를 했을 때는
            // ++i가 수행되면 안 됩니다. i여야 합니다

            // 방법1 : 여기서 i 하나 빼기 (땜빵. 남용하면 나중에 문제)
            // 방법2 : for문의 "반복별 변화"를 조건에 따라 나누기

            // break; // 브레이크 없이 끝까지

            // erase가 사용되었을 때는 i에 변화를 주지 않음
            // : 3이 검색됐으면, 다음 번 검색에서도 i번쨰 순번을 똑같이 검색
        }
        else // 3이 검색이 안 됐으면
        {
            ++i; // 다음 번 검색에서 i 순번을 하나 뒤로 밀기
        }
    }

    // 이렇게 만들면 모든 벡터 내 데이터를 지울 수 있겠죠?

    for (int i = 0; i < vec.size(); ++i)
    {
        cout << vec[i] << endl;
    }

    // 이런 방법으로, 벡터에서 데이터가 여러 개가 나오도라도
    // 반복문과 조건문의 적절한 조합과 응용만 있으면
    // 얼마든지 검색하고 삭제할 수 있습니다

    // 그 외에도 특정 데이터 n개 벡터에 추가하기
    // 어디 위치에 해당 n개 데이터 추가하기...등도 가능

    // 요점 -> 벡터도 결국 배열의 연장. 똑같이 반복문으로, 응용으로 활용할 수 있습니다
}